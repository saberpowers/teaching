# -*- coding: utf-8 -*-
"""pyday_2023-10-13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tL5LfqDZ3qvFyoiLVlIgj--nYU9Zl7YN
"""

!pip install statsbombpy

# Download the data ----

from statsbombpy import sb
import pandas as pd

# Remind ourselves of the competition ID and season ID for EPL 2015-16
competitions = sb.competitions()
competitions.loc[lambda x: x['country_name'] == 'England']

matches = sb.matches(competition_id=2, season_id=27)

# Use list comprehension to download event data for 100 matches (~ 2 seconds per match)
events = pd.concat([sb.events(match_id=x) for x in matches['match_id'][range(100)]])

# Construct the SPADL representation ----

import numpy as np

events_spadl = (
    events
        # By default, events are not sorted by index, and this is a requirement for us
        .sort_values(['match_id', 'index'])
        .assign(
            start_time=lambda x: [60 * int(y[3:5]) + float(y[6:]) for y in x['timestamp']],
            end_time=lambda x: x['start_time'] + np.where(x['duration'].isna(), 0, x['duration']),
            start_loc_x=lambda x: x['location'].apply(lambda y: y[0] if isinstance(y, list) else np.nan),
            start_loc_y=lambda x: x['location'].apply(lambda y: y[1] if isinstance(y, list) else np.nan),
            end_location=lambda x: np.select(
                condlist=[x['type'] == 'Pass', x['type'] == 'Carry', x['type'] == 'Shot', x['type'] == 'Goalkeeper'],
                choicelist=[x['pass_end_location'], x['carry_end_location'], x['shot_end_location'], x['goalkeeper_end_location']],
                default=x['location'],
            ),
            end_loc_x=lambda x: x['end_location'].apply(lambda y: y[0] if isinstance(y, list) else np.nan),
            end_loc_y=lambda x: x['end_location'].apply(lambda y: y[1] if isinstance(y, list) else np.nan),
            body_part=lambda x: np.select(
                condlist=[x['type'] == 'Pass', x['type'] == 'Shot', x['type'] == 'Clearance', x['type'] == 'Goalkeeper'],
                choicelist=[x['pass_body_part'], x['shot_body_part'], x['clearance_body_part'], x['goalkeeper_body_part']],
                default=None,
            ),
            # Manually define the success/failure result for the most frequent events.
            # If we had more time, we'd want to handle ALL events.
            result=lambda x: np.select(
                condlist=[
                    x['type'] == 'Pass',
                    x['type'] == 'Carry',
                    x['type'] == 'Ball Recovery',
                    x['type'] == 'Duel',
                    x['type'] == 'Clearance',
                    x['type'] == 'Dribble',
                    x['type'] == 'Goalkeeper',
                    x['type'] == 'Dispossessed',
                    x['type'] == 'Miscontrol',
                    x['type'] == 'Shot',
                    x['type'] == 'Foul Committed',
                    x['type'] == 'Foul Won',
                    x['type'] == 'Dribbled Past',
                    x['type'] == 'Interception',
                ],
                choicelist=[
                    # Pass
                    np.select(
                        condlist=[x['pass_outcome'].isna(), x['pass_outcome'] == 'Incomplete', x['pass_outcome'] == 'Pass Offside'],
                        choicelist=['success', 'failure', 'offside'],
                        default=None
                    ),
                    'success', # Carry
                    'success', # Ball Recovery
                    # Duel
                    np.select(
                        condlist=[x['duel_type'] == 'Aerial Lost', x['duel_outcome'].isin(['Lost In Play', 'Lost Out']), x['duel_outcome'].isin(['Won', 'Success in Play'])],
                        choicelist=['failure', 'failure', 'success'],
                        default=None
                    ),
                    'success', # Clearance
                    np.where(x['dribble_outcome'] == 'Complete', 'success', 'failure'), # Dribble
                    # Goalkeeper
                    np.select(
                        condlist=[x['goalkeeper_type'].isin(['Shot Faced', 'Shot Saved', 'Collected']), x['goalkeeper_outcome'] == 'Claim'],
                        choicelist=['success', 'success'],
                        default=None
                    ),
                    'failure', # Dispossessed
                    'failure', # Miscontrol
                    np.where(x['shot_outcome'] == 'Goal', 'success', 'failure'),    # Shot
                    'failure', # Foul Committed
                    'success', # Foul Won
                    'success', # Dribbled Past
                    np.where(x['interception_outcome'] == 'Won', 'success', 'failure'), # Interception
                ],
                default=None
            ),
            # Create a new string that encodes both type and result
            type_result=lambda x: x['type'] + '_' + x['result'],
        )
        # Throw out any events for which the result is NA
        .loc[lambda x: ~x['result'].isna()]
)

# Compute outcomes and features for the regression model ----

# This VAEP constant k defines the number of events we look into the future for goal events
k = 10

data = (
    events_spadl
        # Get the SPADL features for the two events that preceded the event in question
        .assign(
            start_time_1=lambda x: x['start_time'].shift(1),
            start_time_2=lambda x: x['start_time'].shift(2),
            end_time_1=lambda x: x['end_time'].shift(1),
            end_time_2=lambda x: x['end_time'].shift(2),
            start_loc_x_1=lambda x: x['start_loc_x'].shift(1),
            start_loc_x_2=lambda x: x['start_loc_x'].shift(2),
            start_loc_y_1=lambda x: x['start_loc_y'].shift(1),
            start_loc_y_2=lambda x: x['start_loc_y'].shift(2),
            end_loc_x_1=lambda x: x['end_loc_x'].shift(1),
            end_loc_x_2=lambda x: x['end_loc_x'].shift(2),
            end_loc_y_1=lambda x: x['end_loc_y'].shift(1),
            end_loc_y_2=lambda x: x['end_loc_y'].shift(2),
            player_id_1=lambda x: x['player_id'].shift(1),
            player_id_2=lambda x: x['player_id'].shift(2),
            team_id_1=lambda x: x['team_id'].shift(1),
            team_id_2=lambda x: x['team_id'].shift(2),
            type_1=lambda x: x['type'].shift(1),
            type_2=lambda x: x['type'].shift(2),
            body_part_1=lambda x: x['body_part'].shift(1),
            body_part_2=lambda x: x['body_part'].shift(2),
            result_1=lambda x: x['result'].shift(1),
            result_2=lambda x: x['result'].shift(2),
            type_result_1=lambda x: x['type_result'].shift(1),
            type_result_2=lambda x: x['type_result'].shift(2),
        )
        # Compute the outcome variables goals scored and goals conceded
        .assign(
            # Need to re-compute index after we've filtered down to SPADL events
            index_spadl=lambda x: range(x.shape[0]),
            # Set up some helper variables so that we can identify when the next goal happens.
            # First, grab the index, match ID and team ID for each goal (if no goal, this is NaN)
            goal_index_spadl=lambda x: np.where(x['shot_outcome'] == 'Goal', x['index_spadl'], np.nan),
            goal_match_id=lambda x: np.where(x['shot_outcome'] == 'Goal', x['match_id'], np.nan),
            goal_team_id=lambda x: np.where(x['shot_outcome'] == 'Goal', x['team_id'], np.nan),
            # Second, fill new columns upward to find the index, etc., of the next goal after each event
            next_goal_index_spadl=lambda x: x['goal_index_spadl'].fillna(method='bfill'),
            next_goal_match_id=lambda x: x['goal_match_id'].fillna(method='bfill'),
            next_goal_team_id=lambda x: x['goal_team_id'].fillna(method='bfill'),
            is_goal_scored=lambda x: list(
                map(    # Convert to int instead of logical so that probabilities below reflect success
                    int,
                    (x['next_goal_match_id'] == x['match_id']) &
                        (x['next_goal_team_id'] == x['team_id']) &
                        (x['next_goal_index_spadl'] <= x['index_spadl'] + 10)
                        # NOTE: I forgot to check that the period is the same
                )
            ),
            is_goal_conceded=lambda x: list(
                map(    # Convert to int instead of logical so that probabilities below reflect success
                    int,
                    (x['next_goal_match_id'] == x['match_id']) &
                        ~(x['next_goal_team_id'] == x['team_id']) &
                        (x['next_goal_index_spadl'] <= x['index_spadl'] + 10)
                        # NOTE: I forgot to check that the period is the same
                )
            ),
        )
        # Calculate predictive features for outcome models (far fewer than we saw in the VAEP paper)
        .assign(
            end_distance_opp_goal=lambda x: np.sqrt((x['end_loc_x']-120)**2 + (x['end_loc_y'] - 40)**2),
            end_distance_own_goal=lambda x: np.sqrt((x['end_loc_x'])**2 + (x['end_loc_y'] - 40)**2),
            downfield_movement=lambda x: x['end_loc_x'] - x['start_loc_x_2'],
        )
)

# Fit the logistic regression models ----

# We're fitting very simple models here, only using the action type, distance to goal and
# downfield movement over the past three actions.

import statsmodels.api as sm
import statsmodels.formula.api as smf

model_goal_scored = (
    smf.glm(
        formula="is_goal_scored ~ type_result + end_distance_opp_goal + downfield_movement",
        # Exclude goals from the outcome model because they result in a goal 100% of the time
        data=data.loc[lambda x: x['type_result'] != "Shot_success"],
        family=sm.families.Binomial()
    )
        .fit()
)

model_goal_conceded = (
    smf.glm(
        formula="is_goal_conceded ~ type_result + end_distance_own_goal + downfield_movement",
        data=data.loc[lambda x: x['type_result'] != "Shot_success"],
        family=sm.families.Binomial()
    )
        .fit()
)

model_goal_scored.summary()

# Extract predictions from models ----

# We have to predict non-goal events separately from goal events because goal events
# were excluded from the training step.
pred_no_goal = (
    data
        .loc[lambda x: x['type_result'] != 'Shot_success']
        .assign(
            pred_goal_scored=lambda x: model_goal_scored.predict(exog=x),
            pred_goal_conceded=lambda x: model_goal_conceded.predict(exog=x),
        )
)

pred_goal = (
    data
        .loc[lambda x: x['type_result'] == 'Shot_success']
        .assign(
            pred_goal_scored=1,     # a goal event ALWAYS leads to a goal scoring
            # We'll assume that a goal event leads to a goal conceded in the next k events at the
            # same rate as non-goal shots (this is probably not a great assumption).
            pred_goal_conceded=pred_no_goal.loc[lambda x: x['type'] == 'Shot']['pred_goal_conceded'].mean(),
        )
)

# Put goal event predictions and non-goal event predictions together and calculate the change
# in goal scored/conceded probabilities which each event.
pred = (
    pd.concat([pred_goal, pred_no_goal])
        .sort_values(['match_id', 'index'])
        .assign(
            # We have to handle three different possibilities:
            # -     Kick off. To avoid debiting players for the change that happens between the
            #       goal event and the kick off, we force the VAEP value for this event to be zero.
            # -     The team ID is the same as the previous event. In this case, we subtract the
            #       goal scored probability of the previous event from the goal scored probability
            #       of the current event.
            # -     The team ID is different from the previous event. In this case, we subtract the
            #       goal CONCEDED probability of the previous event from the goal scored probability
            #       of the current event.
            diff_goal_scored=lambda x: np.select(
                condlist=[x['pass_type'] == 'Kick Off', x['team_id'] == x['team_id'].shift(1), ~(x['team_id'] == x['team_id'].shift(1))],
                choicelist=[0, x['pred_goal_scored'] - x['pred_goal_scored'].shift(1), x['pred_goal_scored'] - x['pred_goal_conceded']],
                default=None
            ),
            # For goal conceded probability, we follow similar logic to the above.
            diff_goal_conceded=lambda x: np.select(
                condlist=[x['pass_type'] == 'Kick Off', x['team_id'] == x['team_id'].shift(1), ~(x['team_id'] == x['team_id'].shift(1))],
                choicelist=[0, x['pred_goal_conceded'] - x['pred_goal_conceded'].shift(1), x['pred_goal_conceded'] - x['pred_goal_scored']],
                default=None
            ),
            # VAEP is defined as change in goal scored prob, minus change in goal conceded prob
            vaep=lambda x: x['diff_goal_scored'] - x['diff_goal_conceded']
        )
)

# Aggregate VAEP by player ----

# First aggregate by player AND action type in case we want to look at the action-specific value
# for each player
player_type_summary = (
    pred
        .groupby(['player_id', 'player', 'type'])
        .agg(
            count=('player_id', 'count'),
            vaep=('vaep', 'sum')
        )
        .reset_index()
)

# Now aggregate by player across action types
player_summary = (
    player_type_summary
        .groupby(['player_id', 'player'])
        .agg(
            count=('count', 'sum'),
            vaep=('vaep', 'sum')
        )
        .reset_index()
)

# Look at the top overall players according to VAEP
player_summary.sort_values('vaep', ascending=False)